use crate::strategies::robert::{Robert, Params};
use crate::player::Player;
use crate::game::Game;
use rayon::prelude::*;
use std::fs;
use rand::prelude::*;

// Evolution configuration
const GENERATIONS: usize = 1000;
const POPULATION_SIZE: usize = 500;
const GAMES_PER_SPECIES: usize = 2000; // 500 * 2000 = 1,000,000 games per generation
const ELITISM_COUNT: usize = 50; // The top 50 advance unchanged
const MUTATION_RATE: f64 = 0.4;  // Probability that a single parameter mutates
const MUTATION_SCALE: f64 = 0.1; // Standard deviation of the change (10%)

pub fn run_evolution() {
    println!("Starting evolution for Robert strategy...");
    println!("Population: {}, Games/Species: {}, Total Games/Gen: {}", 
             POPULATION_SIZE, GAMES_PER_SPECIES, POPULATION_SIZE * GAMES_PER_SPECIES);

    // 1. Load initial population (either from file or default + noise)
    let base_params = Params::load_from_file_or_default("robert_params.txt");
    let mut population: Vec<Params> = (0..POPULATION_SIZE).map(|i| {
        if i == 0 {
            base_params.clone() // The original is always part of the first generation
        } else {
            mutate_params(&base_params) // The rest are variations
        }
    }).collect();

    let mut best_score_all_time = 0.0;

    for generation in 1..=GENERATIONS {
        // 2. Evaluation (Parallel)
        // Calculate the average score for each individual
        let mut results: Vec<(usize, f64)> = (0..POPULATION_SIZE).into_par_iter().map(|idx| {
            let params = &population[idx];
            let score = evaluate_params(params);
            (idx, score)
        }).collect();

        // 3. Sort by score (descending)
        results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

        let best_idx = results[0].0;
        let best_gen_score = results[0].1;
        let best_params = population[best_idx].clone();

        println!("Gen {}: Best Score = {:.4} (Avg of top 10: {:.4})", 
            generation, 
            best_gen_score,
            results.iter().take(10).map(|r| r.1).sum::<f64>() / 10.0
        );

        // Save if we found a new record
        if best_gen_score > best_score_all_time {
            best_score_all_time = best_gen_score;
            println!("  -> New best parameters found! Saving to robert_params.txt...");
            save_params(&best_params, "robert_params.txt");
        }

        // 4. Selection & Mutation for next generation
        let mut new_population = Vec::with_capacity(POPULATION_SIZE);

        // Elitism: carry over the best
        for i in 0..ELITISM_COUNT {
            new_population.push(population[results[i].0].clone());
        }

        // The rest is generated by mutating the top 50% of the current generation
        let mut rng = rand::rng();
        let parents_pool_size = POPULATION_SIZE / 2;
        
        while new_population.len() < POPULATION_SIZE {
            // Select a random parent from the better half
            let random_rank = rng.random_range(0..parents_pool_size);
            let parent_idx = results[random_rank].0;
            let parent_params = &population[parent_idx];
            
            // Create mutated child
            new_population.push(mutate_params(parent_params));
        }

        population = new_population;
    }
}

// Runs the simulations for a specific set of parameters
fn evaluate_params(params: &Params) -> f64 {
    // Robert plays against himself (clone) to optimize for the strategy
    let total_score: u32 = (0..GAMES_PER_SPECIES).map(|_| {
        let p1 = Player::new(Box::new(Robert::new_with_params(*params)));
        let p2 = Player::new(Box::new(Robert::new_with_params(*params)));
        let mut game = Game::new(p1, p2);
        
        loop {
            if let Some(score) = game.game_over() {
                return score as u32;
            }
            game.advance();
        }
    }).sum();

    total_score as f64 / GAMES_PER_SPECIES as f64
}

fn mutate_params(p: &Params) -> Params {
    let mut rng = rand::rng();
    let mut new_p = *p;

    // Helper macro for f64 mutation
    macro_rules! mutate_f64 {
        ($field:ident) => {
            if rng.random_bool(MUTATION_RATE) {
                // Multiplicative mutation (scale invariant)
                let factor = 1.0 + rng.random_range(-MUTATION_SCALE..MUTATION_SCALE);
                new_p.$field *= factor;
                
                // Additive mutation for values close to 0
                if new_p.$field.abs() < 1e-6 {
                    new_p.$field += rng.random_range(-0.1..0.1);
                }
            }
        };
    }

    // Helper macro for i32 mutation
    macro_rules! mutate_i32 {
        ($field:ident) => {
            if rng.random_bool(MUTATION_RATE) {
                if rng.random_bool(0.5) {
                    new_p.$field += 1;
                } else {
                    new_p.$field -= 1;
                }
            }
        };
    }

    // PLAYING
    mutate_i32!(score_play_exponent_probability);
    mutate_f64!(score_play_by_playability_weight);
    mutate_f64!(score_play_badness_mistake_weight);
    mutate_f64!(score_play_can_play_5_sure);
    mutate_f64!(score_play_make_playable);
    mutate_f64!(score_play_make_playable_weighted_by_partner_knowledge);
    mutate_f64!(score_play_make_discardable);
    mutate_f64!(score_play_make_discardable_weighted_by_partner_knowledge);
    mutate_f64!(score_play_sure);
    mutate_f64!(score_play_focused_hint);

    // DISCARDING
    mutate_i32!(score_discard_exponent_probability);
    mutate_f64!(score_discard_value_of_a_hint);
    mutate_f64!(score_discard_probability_weight);
    mutate_f64!(score_discard_badness_mistake_weight);
    mutate_f64!(score_discard_hints_low_weight);

    // HINTING
    mutate_f64!(score_hint_focused_hint);
    mutate_i32!(score_hint_exponent_information_gain);
    mutate_f64!(score_hint_information_gain);
    mutate_f64!(score_hint_make_playable);
    mutate_f64!(score_hint_make_discardable);

    // SPECIAL PENALTIES
    mutate_f64!(score_badness_discard_only_card_left_of_its_kind);

    new_p
}

fn save_params(p: &Params, filename: &str) {
    let mut content = String::new();
    
    macro_rules! write_line {
        ($field:ident) => {
            content.push_str(&format!("{}={}\n", stringify!($field), p.$field));
        };
    }

    write_line!(score_play_base);
    write_line!(score_discard_base);
    write_line!(score_hint_base);
    
    write_line!(score_play_exponent_probability);
    write_line!(score_play_by_playability_weight);
    write_line!(score_play_badness_mistake_weight);
    write_line!(score_play_can_play_5_sure);
    write_line!(score_play_make_playable);
    write_line!(score_play_make_playable_weighted_by_partner_knowledge);
    write_line!(score_play_make_discardable);
    write_line!(score_play_make_discardable_weighted_by_partner_knowledge);
    write_line!(score_play_sure);
    write_line!(score_play_focused_hint);

    write_line!(score_discard_exponent_probability);
    write_line!(score_discard_value_of_a_hint);
    write_line!(score_discard_probability_weight);
    write_line!(score_discard_badness_mistake_weight);
    write_line!(score_discard_hints_low_weight);

    write_line!(score_hint_focused_hint);
    write_line!(score_hint_exponent_information_gain);
    write_line!(score_hint_information_gain);
    write_line!(score_hint_make_playable);
    write_line!(score_hint_make_discardable);

    write_line!(score_badness_discard_only_card_left_of_its_kind);

    if let Err(e) = fs::write(filename, content) {
        println!("Error writing params: {}", e);
    }
}
